#include <sys/wait.h>
#include <sys/types.h> // for pid_t 
#include <unistd.h>
#include <errno.h>
#include <cstdlib>
#include <iostream>
#include <fcntl.h>

#include <fstream> 
#include "mb-app/cache-proxy.hpp"
#include "lib/fs.hpp"

const char *cache_log = "examples/configs/squid/log/cache.log";        // log for debugging info
const char *access_log = "examples/configs/squid/log/access.log";       // log for client request 
const char *cache_store_log = "examples/configs/squid/log/store.log";  // log for stored cache object changes
/** 
    format of store.log
  	time       The time this entry was logged.  The value is the
               raw Unix time plus milliseconds.
    action     One of RELEASE, SWAPIN, or SWAPOUT.
               RELEASE means the object has been removed from the cache.
               SWAPOUT means the object has been saved to disk.
               SWAPIN  means the object existed on disk and has bee
                       swapped into memory.
    status     The HTTP reply code
    The following three fields are timestamps parsed from the HTTP
    reply headers.  All are expressed in Unix time.  A missing header
    is represented with -2 and an unparsable header is represented as -1.
    datehdr    The value of the HTTP Date: reply header.
    lastmod    The value of the HTTP Last-Modified: reply header.
    expires    The value of the HTTP Expires: reply header.
    type       The HTTP Content-Type reply header.
    expect-len The value of the HTTP Content-Length reply header.
               Zero if Content-Length was missing.
    real-len   The number of bytes of content actually read.  If the
               expect-len is non-zero, and not equal to the real-len,
               the object will be released from the cache.
    method     HTTP request method
    key        The cache key.  Often this is simply the URL.  Cache objects
               which never become public will have cache keys that include
               a unique integer sequence number, the request method, and
               then the URL.
*/

/*
 *  format of access.log 
 *  ts 
 *  duration:       request handle
 *  host addr:      
 *  result code:    defined by squid, code is separated by underscore 
										wiki.squid-cache.org/SquidFaq/SquidLogs#Squid_result_codes 
 *  bytes:          include headers and errors
 *  request metd:   could be PURGE in additional supported method identifier
 *  URL:            target url
 *  user:           user who make the request, - for not defined*
 *  hierachy code:  the hit status of the request, DIRECT means no hit
 *  type:           type seen in the HTTP reply header
 */

const std::string curr_dir = fs::get_cwd();
const std::string config_path(curr_dir + "examples/configs/squid/squid.conf");
const std::string config_template_path(curr_dir + "examples/configs/squid/conf.template");
const std::string proxy_path = "/usr/sbin/squid"; 
CacheProxy::CacheProxy(const std::shared_ptr<cpptoml::table>& node)
{
    server_pid = 0;
    if (fs::is_regular_file(config_template_path)t ) {
        bool status = fs::copy(config_template_path, config_path);
        if (!status) {
            Logger::get_instance().err("generation of config is failed");
            exit(EXIT_FAILURE);
        }
    } else {
        Logger::get_instance().err("The examples/configs/squid/conf.template is not regular file");
        exit(EXIT_FAILURE); 
    }
       
    if (node) {
        auto node_config = node->get_as<std::string>("config"); 
        std::string squid("squid");
        auto app = node->get_as<std::string>("app");
        if (app && !squid.compare(*app)){
            auto config = node->get_as<std::string>("config");
            proxy_config = *config;
            // modify the base configuration file, append supported lines of
            // configuration to the file
            config_file_rewrite(proxy_config, true);
        } else {
            Logger::get_instance().err("it is not a squid node");
        }
    } else {
        Logger::get_instance().err("node_config is empty, please check ");
        _exit(EXIT_FAILURE); // terminate the calling process
    }

    proxy_argv.push_back(const_cast<char*>("-NYC"));  // non-background squid, block all fatal signal for the thread, fast reload
    proxy_argv.push_back(const_cast<char*>("-f"));  // use config file
    proxy_argv.push_back(const_cast<char*>(config_path.c_str()));				// configureation file path
    proxy_argv.push_back(NULL);

    Logger::get_instance().info("Cache Proxy is created..");
}

CacheProxy::~CacheProxy()
{
    shutnclean();
    Logger::get_instance().info("Cache Proxy is destroyed..");
}

/** clean cache storage and launch server in child process**/
void CacheProxy::init()
{
    if (server_pid > 0) {
        int status = shutnclean();
        if (status) return;
    }
    pid_t pid;
    if ((pid=fork()) == 0) {
        char * argv[] = {NULL};
        char ** p_argv = &proxy_argv[0];
        int status __attribute__((unused))= execve(proxy_path.c_str(), p_argv, argv);
        Logger::get_instance().err("failed with launch proxy for :" << strerror(errno) << "\n");
    } else if (pid == -1) {
        Logger::get_instance().err("fork failure during cache proxy init");
    } else {
        int status; 
		// 
        pid_t retval = waitpid(pid, &status, WNOHANG);  // TODO check cache.log
        if (!retval) Logger::get_instance().info("child process is launched for squid...");
    } 
}

/** soft reset with sighup**/
void CacheProxy::reset() {
    if (server_pid > 0) {
        // send hup signal to the squid process, HUP will reload the
        // cache-server other than kill it
        int status = kill(server_pid, SIGHUP);
        if (status) {
            Logger::get_instance().info("There has been error in sending out sighup signal to reload the squid server");
        }
    } else {
        Logger.get_instance().err("Server pid file is missing");
    }
}

/** reset one step **/
void CacheProxy::reset_onestep()
{
	// cache manager server who is accepting additional method request
	//http://etutorials.org/Server+Administration/Squid.+The+definitive+guide/Chapter+14.+Monitoring+Squid/14.2+The+Cache+Manager/ 
	
    // TOOD reset with finding the last access.log information and try to remove corresponding cached object by calling script

		// update the hashmap with access log 
		std::ifstream logstream(access_log);
		std::string line; 

		if (log_pos) {
				logstream.seekg(log_pos);
		} else {
				log_pos = logstream.tellg();
		}

    Logger::get_instance().info("The log_position is " << log_pos);
		while (std::getline(logstream, line)) {
				std::string target_url;
        target_url = extract_column("\t", line, 7); // 7th column of acces.log is URL, push entire string log to history stack
				host_access_history.push(line); 
				host_access_count[target_url]++; // increase cache count for url
		}
		//update log pointer
		log_pos = logstream.tellg(); 
		logstream.close();
		
		// reset to last step
		if (host_access_history.empty()) {
				Logger::get_instance().err("there is no objects cached in the disk so far");
		} else {
				std::string last_access = host_access_history.top();
        host_access_history.pop(); // parse the poped string and 
				std::string target = last_access; // split the saved request for the host as key in host_access_count map
        Logger::get_instance().info("start to reset for access ops: " << last_access);
				host_access_count[last_access]--;
				if (!host_access_count[last_access]) {
						// launch the purge when the count is zero
						// TODO deal with version control of the file
						std::string purge_cmd = "squidclient -PURGE " + target;
            std::string retval;
            execute(purge_cmd, retval);
            Logger::get_instance().info("purge result: " << retval);
            // check the return status, or TODO we can use other client to send

            // failure with retrieve success response from client
            if (retval.empty() || retval.find("200") == std::string::npos) {
              Logger::get_instance().err("The purge is not successfully");
            }
				}	
		}
}

/** shutdown running proxy process and clean the cache directory, kill all
 * pinger process **/
int CacheProxy::shutnclean() {
    if (server_pid > 0) {
        Logger::get_instance().info(server_pid);
				std::string squid_kill_cmd = "/bin/kill -INT -" + std::to_string(server_pid);
				std::string pinger_clean_cmd = "/usr/bin/pkill -f pinger";
        int status = system(squid_kill_cmd.c_str());
        if (!status) server_pid = -1;
        else Logger::get_instance().err("Error occurred during termination of proxy");
        status = system(pinger_clean_cmd.c_str());
    } else {
        Logger::get_instance().info("There is no proxy server running");
    } 
    std::string argv = "./examples/configs/squid/clean.sh";
    int status = system(argv.c_str());
    if (status == -1) {
        Logger::get_instance().err( "Error occurred during executing clean.sh", errno);
    } else {
       Logger::get_instance().info("The exit value of subprocess is as followed: ");
    }
    return 0;
}

/** append configuration to base configuration rile **/
void CacheProxy::config_file_rewrite(const std::string& config_content, const bool use_default) {
    if (use_default) {
        Logger::get_instance().info("The configuration is not used: " << config_content); 
    } else {
        Logger::get_instance().info("Start to append config..");
        std::ofstream output_stream(config_path);
        output_stream << config_content;
        output_stream.close();
    }
}

/** execute program in another thread and save the output to buffer**/ 
void CacheProxy::execute(const std::string& command, std::string& retval) {
    std::array<char, 500> buffer;
    // redirect the output file number to process object declared here
    std::unique_ptr<FILE, decltype(&fclose)> pipe(popen(command.c_str(), "r"), fclose);

    if (pipe) {
        Logger::get_instance().err("Problem occurred when opening pipe for logging file" << std::strerror(errno));
        return;
    }
    // start to copy the buffer back 
    while (fgets(buffer.data(), buffer.size(), pipe.get())) {
        retval += buffer.data();
    }
}

/** helper function for extract out certain column from the line**/
std::string CacheProxy::extract_column(const std::string& delimiter, const std::string& original, const int index) {
    std::string retval = nullptr;
  //
    size_t start_index = 0;
    size_t next_index;
    int count = 1;
    std::string line;
    while ((next_index = line.find(delimiter, start_index)) != std::string::npos && count < index) {
        count++;
        start_index = next_index + 1;
    }
    
    return original.substr(start_index, next_index);
}


// replay functionality 
// reset and replay packet history to achieve a spin state 
// 1. overhead with resetting
// 2. inject the packet will cause http request block for long if there are
//    a lot of packets needed to be injected
// 3. packet definition should be derived from config
